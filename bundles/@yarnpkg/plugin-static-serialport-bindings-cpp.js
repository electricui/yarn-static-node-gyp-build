/* eslint-disable */
module.exports = {
name: "@yarnpkg/plugin-static-serialport-bindings-cpp",
factory: function (require) {
var plugin;plugin=(()=>{var e={548:(e,n,r)=>{"use strict";r.r(n),r.d(n,{default:()=>p});const t=require("@yarnpkg/core"),i=require("@yarnpkg/fslib"),o=require("stream"),s=require("@yarnpkg/libzip");var a=r(516);async function c(e,n,r){const{packageLocation:c,packageFs:p}=await async function(e,n){const r=n.storedPackages.get(e.locatorHash);if(!r)throw new Error(`Package for ${t.structUtils.prettyLocator(n.configuration,e)} not found in the project`);return await i.ZipOpenFS.openPromise(async e=>{const s=n.configuration,a=n.configuration.getLinkers(),c={project:n,report:new t.StreamReport({stdout:new o.PassThrough,configuration:s})},p=a.find(e=>e.supportsPackage(r,c));if(!p)throw new Error(`The package ${t.structUtils.prettyLocator(n.configuration,r)} isn't supported by any of the available linkers`);const u=await p.findPackageLocation(r,c);return{packageLocation:u,packageFs:new i.CwdFS(u,{baseFs:e})}},{libzip:await(0,s.getLibzipPromise)()})}(e,n),u=(0,a.path)(c),l=i.ppath.relative(c,u),d=i.ppath.relative(i.ppath.join(c,"dist"),u),f=i.ppath.join(c,"dist","load-bindings.js");if(!u)return void r.report.reportWarning(t.MessageName.UNNAMED,"Couldn't find prebuild for "+t.structUtils.stringifyLocator(e));r.report.reportInfo(t.MessageName.UNNAMED,`Found prebuild for ${t.structUtils.stringifyLocator(e)}: ${l}`),r.report.reportInfo(t.MessageName.UNNAMED,"relativeLocation: "+d),r.report.reportInfo(t.MessageName.UNNAMED,"loadBindingsFilePath: "+f);const g=`"use strict";\n// Automatically generated bindings file for ${t.structUtils.stringifyIdent(e)}\n// Package version: ${e.version}\n// Bindings taken from: ${l}\n\nconst binding = require("${d}");\n\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", { value: true });\nexports.asyncWrite = exports.asyncRead = exports.asyncUpdate = exports.asyncSet = exports.asyncOpen = exports.asyncList = exports.asyncGetBaudRate = exports.asyncGet = exports.asyncFlush = exports.asyncDrain = exports.asyncClose = void 0;\nconst util_1 = require("util");\nconst path_1 = require("path");\nexports.asyncClose = binding.close ? (0, util_1.promisify)(binding.close) : async () => { throw new Error('"binding.close" Method not implemented'); };\nexports.asyncDrain = binding.drain ? (0, util_1.promisify)(binding.drain) : async () => { throw new Error('"binding.drain" Method not implemented'); };\nexports.asyncFlush = binding.flush ? (0, util_1.promisify)(binding.flush) : async () => { throw new Error('"binding.flush" Method not implemented'); };\nexports.asyncGet = binding.get ? (0, util_1.promisify)(binding.get) : async () => { throw new Error('"binding.get" Method not implemented'); };\nexports.asyncGetBaudRate = binding.getBaudRate ? (0, util_1.promisify)(binding.getBaudRate) : async () => { throw new Error('"binding.getBaudRate" Method not implemented'); };\nexports.asyncList = binding.list ? (0, util_1.promisify)(binding.list) : async () => { throw new Error('"binding.list" Method not implemented'); };\nexports.asyncOpen = binding.open ? (0, util_1.promisify)(binding.open) : async () => { throw new Error('"binding.open" Method not implemented'); };\nexports.asyncSet = binding.set ? (0, util_1.promisify)(binding.set) : async () => { throw new Error('"binding.set" Method not implemented'); };\nexports.asyncUpdate = binding.update ? (0, util_1.promisify)(binding.update) : async () => { throw new Error('"binding.update" Method not implemented'); };\nexports.asyncRead = binding.read ? (0, util_1.promisify)(binding.read) : async () => { throw new Error('"binding.read" Method not implemented'); };\nexports.asyncWrite = binding.read ? (0, util_1.promisify)(binding.write) : async () => { throw new Error('"binding.write" Method not implemented'); };`;await p.writeFilePromise(f,g)}const p={hooks:{afterAllInstalled:async function(e,n){await async function(e,n){for(const r of e.storedPackages.values())if("bindings-cpp"===r.name&&"serialport"===r.scope)try{await n.report.startTimerPromise("Static native dependency resolution",async()=>{await c(r,e,n)})}catch(e){n.report.reportInfo(t.MessageName.UNNAMED,"Couldn't mutate bindings for "+t.structUtils.stringifyLocator(r)),console.error(e)}}(e,n)}}}},516:(e,n,r)=>{var t=r(747),i=r(622),o=r(87),s=require,a=process.config&&process.config.variables||{},c=!!process.env.PREBUILDS_ONLY,p=process.versions.modules,u=!(!process.versions||!process.versions.electron)||!!process.env.ELECTRON_RUN_AS_NODE||"undefined"!=typeof window&&window.process&&"renderer"===window.process.type?"electron":process.versions&&process.versions.nw?"node-webkit":"node",l=process.env.npm_config_arch||o.arch(),d=process.env.npm_config_platform||o.platform(),f=process.env.LIBC||(function(e){return"linux"===e&&t.existsSync("/etc/alpine-release")}(d)?"musl":"glibc"),g=process.env.ARM_VERSION||("arm64"===l?"8":a.arm_version)||"",m=(process.versions.uv||"").split(".")[0];function y(e){return s(y.path(e))}function b(e){try{return t.readdirSync(e)}catch(e){return[]}}function h(e,n){var r=b(e).filter(n);return r[0]&&i.join(e,r[0])}function v(e){return/\.node$/.test(e)}function w(e){var n=e.split("-");if(2===n.length){var r=n[0],t=n[1].split("+");if(r&&t.length&&t.every(Boolean))return{name:e,platform:r,architectures:t}}}function _(e,n){return function(r){return null!=r&&(r.platform===e&&r.architectures.includes(n))}}function x(e,n){return e.architectures.length-n.architectures.length}function E(e){var n=e.split("."),r={file:e,specificity:0};if("node"===n.pop()){for(var t=0;t<n.length;t++){var i=n[t];if("node"===i||"electron"===i||"node-webkit"===i)r.runtime=i;else if("napi"===i)r.napi=!0;else if("abi"===i.slice(0,3))r.abi=i.slice(3);else if("uv"===i.slice(0,2))r.uv=i.slice(2);else if("armv"===i.slice(0,4))r.armv=i.slice(4);else{if("glibc"!==i&&"musl"!==i)continue;r.libc=i}r.specificity++}return r}}function M(e,n){return function(r){return null!=r&&(!(r.runtime!==e&&!function(e){return"node"===e.runtime&&e.napi}(r))&&(!(r.abi!==n&&!r.napi)&&((!r.uv||r.uv===m)&&((!r.armv||r.armv===g)&&(!r.libc||r.libc===f)))))}}function k(e){return function(n,r){return n.runtime!==r.runtime?n.runtime===e?-1:1:n.abi!==r.abi?n.abi?-1:1:n.specificity!==r.specificity?n.specificity>r.specificity?-1:1:0}}e.exports=y,y.path=function(e){e=i.resolve(e||".");try{var n=s(i.join(e,"package.json")).name.toUpperCase().replace(/-/g,"_");process.env[n+"_PREBUILD"]&&(e=process.env[n+"_PREBUILD"])}catch(e){}if(!c){var r=h(i.join(e,"build/Release"),v);if(r)return r;var t=h(i.join(e,"build/Debug"),v);if(t)return t}var o=N(e);if(o)return o;var a=N(i.dirname(process.execPath));if(a)return a;var y=["platform="+d,"arch="+l,"runtime="+u,"abi="+p,"uv="+m,g?"armv="+g:"","libc="+f,"node="+process.versions.node,process.versions.electron?"electron="+process.versions.electron:"","webpack=true"].filter(Boolean).join(" ");throw new Error("No native build was found for "+y+"\n    loaded from: "+e+"\n");function N(e){var n=b(i.join(e,"prebuilds")).map(w).filter(_(d,l)).sort(x)[0];if(n){var r=i.join(e,"prebuilds",n.name),t=b(r).map(E).filter(M(u,p)).sort(k(u))[0];return t?i.join(r,t.file):void 0}}},y.parseTags=E,y.matchTags=M,y.compareTags=k,y.parseTuple=w,y.matchTuple=_,y.compareTuples=x},747:e=>{"use strict";e.exports=require("fs")},87:e=>{"use strict";e.exports=require("os")},622:e=>{"use strict";e.exports=require("path")}},n={};function r(t){if(n[t])return n[t].exports;var i=n[t]={exports:{}};return e[t](i,i.exports,r),i.exports}return r.d=(e,n)=>{for(var t in n)r.o(n,t)&&!r.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:n[t]})},r.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n),r.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r(548)})();
return plugin;
}
};